<!DOCTYPE html>
<!--
Created using JS Bin
http://jsbin.com

Copyright (c) 2019 by yortuc (http://jsbin.com/fivojuc/32/edit)

Released under the MIT license: http://jsbin.mit-license.org
-->
<meta name="robots" content="noindex">
<html>
<head>
<meta name="description" content="WindowManager">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JS Bin</title>
</head>
<body style="background-color: #f7f7f7">
  <button id="b" style="display:block">+ New window</button>
  <canvas id="c"></canvas>

<script id="jsbin-javascript">
const canvas =document.getElementById('c');
var c = document.getElementById('c').getContext('2d');

CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  this.beginPath();
  this.moveTo(x+r, y);
  this.arcTo(x+w, y,   x+w, y+h, r);
  this.arcTo(x+w, y+h, x,   y+h, r);
  this.arcTo(x,   y+h, x,   y,   r);
  this.arcTo(x,   y,   x+w, y,   r);
  this.closePath();
  return this;
}

class Window {
  constructor(opts){
    this.pos = {x: opts.x, y: opts.y, width: opts.width, height: opts.height}
    this.cap = {text: opts.title, fontSize: 16, color: opts.capColor || "black"}
    this.z = -1
    this.hasFocus = opts.hasFocus
    this.gripMargin = 15
    this.wm = opts.wm
    this.bgColor = opts.bgColor || "white"
  }

  _renderButtons() {
    if(this.hasFocus){
      drawCircle(this.pos.x + 20, this.pos.y + 20, 7).stroke()
      drawCircle(this.pos.x + 44, this.pos.y + 20, 7).stroke()
      drawCircle(this.pos.x + 66, this.pos.y + 20, 7).stroke()
    }
    c.fillStyle = this.hasFocus ? "rgb(255,45,85)" : "#ccc"
    drawCircle(this.pos.x + 20, this.pos.y + 20, 7).fill()

    c.fillStyle = this.hasFocus ? "rgb(255,204,0)" : "#ccc"
    drawCircle(this.pos.x + 44, this.pos.y + 20, 7).fill()

    c.fillStyle = this.hasFocus ? "rgb(40,205,65)" : "#ccc"
    drawCircle(this.pos.x + 66, this.pos.y + 20, 7).fill()

  }
  
  _renderWindow() {
    // fill window 
    c.save()
        
    if(this.hasFocus){
      c.shadowColor = '#999';
      c.shadowBlur = 15;
      c.shadowOffsetY = 15;
    }

    c.fillStyle = this.bgColor;
    c.roundRect(this.pos.x, this.pos.y, this.pos.width, this.pos.height, 10).fill();    
    c.restore()
    
    // draw resize grip
    c.moveTo(this.pos.x + this.pos.width - this.gripMargin, this.pos.y + this.pos.height)
    c.lineTo(this.pos.x + this.pos.width, this.pos.y + this.pos.height - this.gripMargin)
    c.moveTo(this.pos.x + this.pos.width - this.gripMargin/1.5, this.pos.y + this.pos.height)
    c.lineTo(this.pos.x + this.pos.width, this.pos.y + this.pos.height - this.gripMargin/1.5)
  }

  _renderCaption() {
    c.fillStyle = this.cap.color
    c.font = this.cap.fontSize + "px Verdana";
    const cWidth = c.measureText(this.cap.text).width
    const cLeft = this.pos.x + (this.pos.width - cWidth)/2
    const cap = {x: cLeft, y: this.pos.y + 27, text: this.cap.text}
    cap.length = c.measureText(cap.txt).width
    c.fillText(cap.text, cap.x, cap.y);
    c.moveTo(this.pos.x, this.pos.y+40);
    c.lineTo(this.pos.x + this.pos.width, this.pos.y+40);
    c.stroke();
  }
  
  render(){
    this._renderWindow()
    this._renderCaption()
    this._renderButtons()
  }

}

class WindowManager {
  constructor(wins, width, height){
    this.windows = wins
    this.topWin = wins[0]
    this.width = width
    this.height = height
    canvas.width = width
    canvas.height = height

    let start = null, 
        end = null,
        resizing = false;
    
    document.addEventListener("mousedown", function(e){
      start = getPosition(e);
      this.topWin = this.getTopMostWin(this.getWinsAtPoint(start));
      
      if(this.topWin){
        resizing = this.isPointInGrip(start, this.topWin)
        this.makeTopWindow(this.topWin)
        this.render();
      }
    }.bind(this))

    document.addEventListener("mouseup", function(e){
      start = null
      end = null
    })
    
    document.addEventListener("mousemove", function(e){
      const curPos = getPosition(e)
      
      if (start && this.topWin){
        const delta = {x: curPos.x - start.x, y: curPos.y - start.y}
        // check if resizing or dragging the window
        if(resizing){
         this.topWin.pos.width += delta.x
         this.topWin.pos.height += delta.y
        }
        else{
         this.topWin.pos.x += delta.x
         this.topWin.pos.y += delta.y
        }
        this.render()
        start = curPos;
      }
      
      // change cursor
      if(this.topWin && this.isPointInGrip(curPos, this.topWin)){
        canvas.style.cursor="nwse-resize"
      } else{
        canvas.style.cursor="default"
      }
    }.bind(this));
 }
  
  isPointInGrip(point, win) {
    return (point.x <= win.pos.x + win.pos.width &&
            point.x >= win.pos.x + win.pos.width - win.gripMargin &&
            point.y <= win.pos.y + win.pos.height &&
            point.y >= win.pos.y + win.pos.height - win.gripMargin);
  }
  
  makeTopWindow(win){
    this.windows.filter((w) => {
      if(w !== win) return win
    })
    this.windows.push(win);
  }
  
 render(){
    // clear screen
    c.fillStyle = "#f7f7f7"
    c.fillRect(0, 0, this.width, this.height);
   
    this.windows.forEach(function(w, index){
      w.z = index
      if(w == this.topWin){
        w.hasFocus = true
      } else {
        w.hasFocus = false
      }
      w.render();
    }.bind(this))
  }
  
  getWinsAtPoint(p){
    const wins = this.windows.filter((w) => {
      const x1 = w.pos.x;
      const y1 = w.pos.y;
      const x2 = w.pos.x + w.pos.width;
      const y2 = w.pos.y + w.pos.height;
      if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2){
        return w
      }
    })
    return wins
  }
  
  getTopMostWin(wins) {
    wins.sort((w1, w2) => { 
      if(w1.z > w2.z) return -1
      if(w1.z < w2.z) return 1
      if(w1.z === w2.z) return 0
    })
    return wins[0];
  }
  
  closeWindow(win){
    this.windows = this.windows.filter((w) => w!==win);
  }
}

const w1 = new Window({title:"Hello World!", x: 100, y: 100, width: 360, height: 240})
const w2 = new Window({title:"Calculator", x: 500, y: 180, width: 260, height: 240 })

const wm = new WindowManager([w1, w2], 1200, 800)
wm.render()


function getPosition(event){
  var x = event.x;
  var y = event.y;
  var canvas = document.getElementById("c");
  x -= canvas.offsetLeft;
  y -= canvas.offsetTop;
  return {x, y}
}

function drawCircle(x,y,r){
  c.beginPath();
  c.arc(x, y, r, 0, 2 * Math.PI);
  return c
}

document.getElementById("b").onclick = function(){
  const num = wm.windows.length + 1
  const newWin = new Window({title:"New window " + num, x: 50 * num, y: 50 * num, width: 360, height: 240})
  wm.windows.push(newWin)
  wm.topWin = newWin
  wm.render()
}


</script>
</body>
</html>